/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AprilsAutomaticTimelinesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/utils.ts
function getMetadataKey(cachedMetadata, key, type) {
  if (!cachedMetadata.frontmatter)
    return void 0;
  return typeof cachedMetadata.frontmatter[key] === type ? cachedMetadata.frontmatter[key] : void 0;
}
var isDefined = (argument) => argument !== void 0;
var isDefinedAsString = (argument) => typeof argument === "string";
function findLastIndex(arr, predicate) {
  const length = arr ? arr.length : 0;
  if (!length) {
    return -1;
  }
  let index = length - 1;
  while (index--)
    if (predicate(arr[index]))
      return index;
  return -1;
}
var lerp = (a, b, t) => a + t * (b - a);
var inLerp = (a, b, v) => (v - a) / (b - a);
var measureTime = (str) => {
  const value = `[April's automatic timelines] - ${str}`;
  console.time(value);
  return () => {
    console.timeEnd(value);
  };
};
function getChildAtIndexInHTMLElement(el, index) {
  const child = el.children.item(index);
  if (!child)
    throw new Error(`Missing child @ index ${index} for element`);
  return child;
}
function createElementShort(el, element, classes, content) {
  const out = el.createEl(element);
  if (classes instanceof Array)
    out.addClass(...classes);
  else if (classes)
    out.addClass(classes);
  if (content !== void 0)
    out.innerHTML = content.toString();
  return out;
}

// src/cardData.ts
var import_obsidian = require("obsidian");
var RENDER_GREENLIGHT_METADATA_KEY = ["aat-render-enabled"];
async function getDataFromNote(context, tagsToFind, settings) {
  const { cachedMetadata } = context;
  const { frontmatter: metaData } = cachedMetadata;
  if (!metaData)
    return void 0;
  if (!RENDER_GREENLIGHT_METADATA_KEY.some((key) => metaData[key] === true))
    return void 0;
  if (!metaData.timelines || !(metaData.timelines instanceof Array) || !metaData.timelines.length)
    return void 0;
  const timelineTags = metaData.timelines.filter(isDefinedAsString);
  if (!timelineTags.length || !timelineTags.some((tag) => tagsToFind.includes(tag)))
    return void 0;
  return {
    cardData: await extractCardData(context, settings),
    context
  };
}
async function extractCardData(context, settings) {
  var _a, _b;
  const { file, cachedMetadata: c } = context;
  const rawFileContent = await file.vault.cachedRead(file);
  const fileTitle = ((_a = c == null ? void 0 : c.frontmatter) == null ? void 0 : _a[settings.eventTitleOverride]) || file.basename;
  return {
    title: fileTitle,
    body: getBodyFromContextOrDocument(rawFileContent, context),
    imageURL: getImageUrlFromContextOrDocument(
      rawFileContent,
      context,
      settings
    ),
    startDate: getMetadataKey(c, settings.eventStartDate, "number"),
    endDate: (_b = getMetadataKey(c, settings.eventEndDate, "number")) != null ? _b : getMetadataKey(c, settings.eventEndDate, "boolean")
  };
}
function getBodyFromContextOrDocument(rawFileText, context) {
  var _a;
  const {
    cachedMetadata: { frontmatter: metadata }
  } = context;
  const overrideBody = (_a = metadata == null ? void 0 : metadata["aat-body"]) != null ? _a : null;
  if (!rawFileText)
    return overrideBody;
  const rawTextArray = rawFileText.split("\n");
  rawTextArray.shift();
  const processedArray = rawTextArray.slice(rawTextArray.indexOf("---") + 1);
  const finalString = processedArray.join("\n").trim();
  const out = finalString.replace(/\[\[([a-z0-9 ]*)\]\]/gi, "<b>$1</b>").replace(/\[\[[a-z0-9 ]*\|([a-z0-9 ]*)\]\]/gi, "<b>$1</b>").replace(/!\[.*\]\(.*\)/gi, "").replace(/#|!\[\[.*\]\]/gi, "").trim();
  return out;
}
function getImageUrlFromContextOrDocument(rawFileText, context, settings) {
  const {
    cachedMetadata: { frontmatter: metadata },
    file: currentFile,
    app
  } = context;
  const {
    vault,
    metadataCache: { getFirstLinkpathDest }
  } = app;
  const override = metadata == null ? void 0 : metadata[settings.eventPictureOverride];
  if (override)
    return override;
  const internalLinkMatch = rawFileText.match(/!\[\[(?<src>.*)\]\]/);
  const matchs = internalLinkMatch || rawFileText.match(/!\[.*\]\((?<src>.*)\)/);
  if (!matchs || !matchs.groups || !matchs.groups.src)
    return null;
  if (internalLinkMatch) {
    const file = getFirstLinkpathDest.bind(app.metadataCache)(
      matchs.groups.src,
      currentFile.path
    );
    if (file instanceof import_obsidian.TFile)
      return vault.getResourcePath(file);
    return null;
  } else
    return encodeURI(matchs.groups.src);
}

// src/timelineMarkup.ts
function setupTimelineCreation(app, element, timelineFile) {
  const { vault, metadataCache } = app;
  const fileArray = vault.getMarkdownFiles();
  const cardListRootElement = element.createDiv();
  const timelineRootElement = element.createDiv();
  element.classList.add("aat-vertical-timeline");
  cardListRootElement.classList.add("aat-card-list-root");
  timelineRootElement.classList.add("aat-timeline-root");
  const dataBundleArray = fileArray.reduce((accumulator, file) => {
    const cachedMetadata = metadataCache.getFileCache(file);
    if (cachedMetadata)
      accumulator.push({
        app,
        timelineFile,
        file,
        cachedMetadata,
        elements: {
          timelineRootElement,
          cardListRootElement
        }
      });
    return accumulator;
  }, []);
  return dataBundleArray;
}

// src/cardMarkup.ts
function createCardFromBuiltContext({
  elements: { cardListRootElement },
  file
}, { body, title, imageURL, startDate, endDate }) {
  const cardBaseDiv = createElementShort(cardListRootElement, "a", [
    "internal-link",
    "aat-card"
  ]);
  cardBaseDiv.setAttribute("href", file.path);
  if (imageURL) {
    createElementShort(cardBaseDiv, "img", "aat-card-image").setAttribute(
      "src",
      imageURL
    );
    cardBaseDiv.addClass("aat-card-has-image");
  }
  const cardTextWraper = createElementShort(
    cardBaseDiv,
    "div",
    "aat-card-text-wraper"
  );
  const titleWrap = createElementShort(
    cardTextWraper,
    "header",
    "aat-card-head-wrap"
  );
  createElementShort(titleWrap, "h2", "aat-card-title", title);
  if (isDefined(startDate) || isDefined(endDate)) {
    const hasStart = isDefined(startDate);
    const hasEnd = isDefined(endDate);
    const both = hasStart && hasEnd;
    createElementShort(
      titleWrap,
      "h4",
      "aat-card-start-date",
      `${both ? "From" : ""} ${startDate} ${hasEnd ? `to ${typeof endDate === "number" ? endDate : "now"}` : ""}`.trim()
    );
  }
  createElementShort(
    cardTextWraper,
    "p",
    "aat-card-body",
    body ? body : "No body for this note :("
  );
}

// src/rangeData.ts
function getAllRangeData(collection) {
  if (!collection.length)
    return [];
  return collection.reduce(
    (accumulator, relatedCardData, index) => {
      const {
        context: {
          elements: { timelineRootElement, cardListRootElement }
        },
        cardData: { startDate, endDate }
      } = relatedCardData;
      if (!isDefined(startDate) || !isDefined(endDate) || endDate === false)
        return accumulator;
      if (endDate !== true && endDate < startDate)
        return accumulator;
      const timelineLength = timelineRootElement.offsetHeight;
      const targetCard = cardListRootElement.children.item(
        index
      );
      if (!targetCard)
        return accumulator;
      const cardRelativeTopPosition = targetCard.offsetTop;
      let targetPosition;
      if (endDate === true)
        targetPosition = timelineLength;
      else
        targetPosition = findEndPositionForDate(
          endDate,
          collection.slice(index),
          timelineLength,
          cardListRootElement,
          index
        );
      accumulator.push({
        relatedCardData: {
          ...relatedCardData,
          cardData: {
            ...relatedCardData.cardData,
            endDate,
            startDate
          }
        },
        targetPosition,
        cardRelativeTopPosition,
        index
      });
      return accumulator;
    },
    []
  );
}
function findEndPositionForDate(date, collection, timelineLength, rootElement, indexOffset) {
  if (collection.length <= 1)
    return timelineLength;
  try {
    const { start, end } = findBoundaries(
      date,
      collection,
      rootElement,
      indexOffset
    );
    const t = inLerp(start.date, end.date, date);
    return lerp(start.top, end.top, t);
  } catch (_) {
    return timelineLength;
  }
}
function findBoundaries(date, collection, rootElement, indexOffset) {
  const firstOverIndex = collection.findIndex(
    ({ cardData: { startDate } }) => isDefined(startDate) ? startDate > date : false
  );
  if (firstOverIndex === -1)
    throw new Error(
      "No first over found - Can't draw range since there are no other two start date to referrence it's position"
    );
  const lastUnderIndex = findLastIndex(
    collection,
    ({ cardData: { startDate } }) => isDefined(startDate) ? startDate <= date : false
  );
  if (lastUnderIndex === -1)
    throw new Error(
      "No last under found - Can't draw range since there are no other two start date to referrence it's position"
    );
  return {
    start: {
      top: getChildAtIndexInHTMLElement(
        rootElement,
        lastUnderIndex + indexOffset
      ).offsetTop,
      date: collection[lastUnderIndex].cardData.startDate
    },
    end: {
      top: getChildAtIndexInHTMLElement(
        rootElement,
        firstOverIndex + indexOffset
      ).offsetTop,
      date: collection[firstOverIndex].cardData.startDate
    }
  };
}

// src/rangeMarkup.ts
var AVAILABLE_COLORS = [
  "red",
  "orange",
  "yellow",
  "green",
  "cyan",
  "blue",
  "purple",
  "pink"
];
function renderRanges(ranges, rootElement) {
  const endDates = AVAILABLE_COLORS.map(
    () => void 0
  );
  ranges.forEach((range) => {
    const {
      relatedCardData: {
        cardData: { startDate, endDate }
      }
    } = range;
    const offsetIndex = endDates.findIndex(
      (date) => !isDefined(date) || date !== true && startDate > date
    );
    if (offsetIndex === -1)
      return;
    renderSingleRange(range, offsetIndex, rootElement);
    endDates[offsetIndex] = endDate;
  });
}
function renderSingleRange({
  relatedCardData: {
    context: {
      elements: { timelineRootElement, cardListRootElement }
    }
  },
  targetPosition,
  cardRelativeTopPosition,
  index
}, offset, rootElelement) {
  const el = createElementShort(
    timelineRootElement,
    "div",
    "aat-range-element"
  );
  el.style.height = `${targetPosition - cardRelativeTopPosition}px`;
  el.style.top = `${cardRelativeTopPosition}px`;
  el.style.left = `${offset * 12}px`;
  el.style.backgroundColor = `var(--color-${AVAILABLE_COLORS[offset]})`;
  const relativeCardClassName = "aat-highlight-relative-card-to-range";
  el.onmouseenter = () => {
    const relativeCard = getChildAtIndexInHTMLElement(
      cardListRootElement,
      index
    );
    relativeCard.classList.add(relativeCardClassName);
  };
  el.onmouseleave = () => {
    const relativeCard = getChildAtIndexInHTMLElement(
      cardListRootElement,
      index
    );
    relativeCard.classList.remove(relativeCardClassName);
  };
  el.onclick = () => {
    const el2 = window.document.querySelector(
      ".markdown-reading-view > .markdown-preview-view"
    );
    if (!el2)
      return;
    el2.scrollTo({
      top: cardRelativeTopPosition + rootElelement.offsetTop - 8,
      behavior: "smooth"
    });
  };
}

// src/settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_METADATA_KEYS = {
  eventStartDate: "aat-event-start-date",
  eventEndDate: "aat-event-end-date",
  eventTitleOverride: "aat-event-title",
  eventBodyOverride: "aat-event-body",
  eventPictureOverride: "aat-event-picture"
};
var TimelineSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    this.containerEl.empty();
    this.newKeyChangeSetting(
      "Event start key",
      "The key that determines the start of an event in a note",
      "eventStartDate"
    );
    this.newKeyChangeSetting(
      "Event end key",
      "The key that determines the end of an event in a note",
      "eventEndDate"
    );
    this.newKeyChangeSetting(
      "Event title override",
      "The key for the title override in each notes metadata",
      "eventTitleOverride"
    );
    this.newKeyChangeSetting(
      "Event image override",
      "The key for the image override in each notes metadata",
      "eventPictureOverride"
    );
    this.newKeyChangeSetting(
      "Event body override",
      "The key for the body override in each notes metadata",
      "eventBodyOverride"
    );
  }
  newKeyChangeSetting(title, desc, key) {
    new import_obsidian2.Setting(this.containerEl).setName(title).setDesc(desc).addText(
      (text) => text.setPlaceholder(DEFAULT_METADATA_KEYS[key]).setValue(this.plugin.settings[key]).onChange(async (value) => {
        this.plugin.settings[key] = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// main.ts
var AprilsAutomaticTimelinesPlugin = class extends import_obsidian3.Plugin {
  /**
   * The default onload method of a obsidian plugin
   * See the official documentation for more details
   */
  async onload() {
    await this.loadSettings();
    this.registerMarkdownCodeBlockProcessor(
      "aat-vertical",
      (source, element, context) => {
        this.run(source, element, context);
      }
    );
  }
  onunload() {
  }
  /**
   * Main runtime function to process a single timeline.
   *
   * @param { string } source - The content found in the markdown block.
   * @param { HTMLElement } element - The root element of all the timeline.
   * @param { MarkdownPostProcessorContext } param2 - The context provided by obsidians `registerMarkdownCodeBlockProcessor()` method.
   */
  async run(source, element, { sourcePath }) {
    const runtimeTime = measureTime("Run time");
    const { app } = this;
    const tagsToFind = source.split(" ").map((e) => e.replace("\n", ""));
    const creationContext = setupTimelineCreation(app, element, sourcePath);
    const cardDataTime = measureTime("Data fetch");
    const cards = (await Promise.all(
      creationContext.map(
        (e) => getDataFromNote(e, tagsToFind, this.settings)
      )
    )).filter(isDefined).sort(
      ({ cardData: { startDate: a } }, { cardData: { startDate: b } }) => {
        if (!isDefined(a) && !isDefined(b))
          return 0;
        if (!isDefined(a))
          return 1;
        if (!isDefined(b))
          return -1;
        return a - b;
      }
    );
    cardDataTime();
    const cardRenderTime = measureTime("Card Render");
    cards.forEach(
      ({ context, cardData }) => createCardFromBuiltContext(context, cardData)
    );
    cardRenderTime();
    const rangeDataFecthTime = measureTime("Range Data");
    const ranges = getAllRangeData(cards);
    rangeDataFecthTime();
    const rangeRenderTime = measureTime("Range Render");
    renderRanges(ranges, element);
    rangeRenderTime();
    runtimeTime();
  }
  /**
   * Loads the saved settings from the local device and sets up the setting tabs in the plugin options.
   */
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_METADATA_KEYS,
      await this.loadData()
    );
    this.addSettingTab(new TimelineSettingTab(this.app, this));
  }
  /**
   * Saves the settings in obsidian.
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
